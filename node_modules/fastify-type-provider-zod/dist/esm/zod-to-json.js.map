{"version":3,"file":"zod-to-json.js","sources":["../../src/zod-to-json.ts"],"sourcesContent":["import { z } from 'zod/v4'\n\nconst getSchemaId = (id: string, io: 'input' | 'output') => {\n  return io === 'input' ? `${id}Input` : id\n}\n\nconst getReferenceUri = (id: string, io: 'input' | 'output') => {\n  return `#/components/schemas/${getSchemaId(id, io)}`\n}\n\nfunction isZodDate(entity: unknown): entity is z.ZodDate {\n  // @ts-expect-error this is expected\n  return entity.constructor.name === 'ZodDate'\n}\n\nconst getOverride = (\n  ctx: {\n    zodSchema: z.core.$ZodType\n    jsonSchema: z.core.JSONSchema.BaseSchema\n  },\n  io: 'input' | 'output',\n) => {\n  if (io === 'output') {\n    // Allow dates to be represented as strings in output schemas\n    if (isZodDate(ctx.zodSchema)) {\n      ctx.jsonSchema.type = 'string'\n      ctx.jsonSchema.format = 'date-time'\n    }\n  }\n}\n\nconst deleteInvalidProperties: (\n  schema: z.core.JSONSchema.BaseSchema,\n) => Omit<z.core.JSONSchema.BaseSchema, 'id' | '$schema'> = (schema) => {\n  const object = { ...schema }\n\n  delete object.id\n  delete object.$schema\n\n  return object\n}\n\nexport const zodSchemaToJson: (\n  zodSchema: z.ZodType,\n  registry: z.core.$ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n) => ReturnType<typeof deleteInvalidProperties> = (zodSchema, registry, io) => {\n  const result = z.toJSONSchema(zodSchema, {\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n    external: {\n      registry,\n      uri: (id) => getReferenceUri(id, io),\n      defs: {},\n    },\n    override: (ctx) => getOverride(ctx, io),\n  })\n\n  const jsonSchema = deleteInvalidProperties(result)\n\n  return jsonSchema\n}\n\nexport const zodRegistryToJson: (\n  registry: z.core.$ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n) => Record<string, z.core.JSONSchema.BaseSchema> = (registry, io) => {\n  const result = z.toJSONSchema(registry, {\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n    uri: (id) => getReferenceUri(id, io),\n    external: {\n      registry,\n      uri: (id) => getReferenceUri(id, io),\n      defs: {},\n    },\n    override: (ctx) => getOverride(ctx, io),\n  }).schemas\n\n  const jsonSchemas: Record<string, z.core.JSONSchema.BaseSchema> = {}\n\n  for (const id in result) {\n    jsonSchemas[getSchemaId(id, io)] = deleteInvalidProperties(result[id])\n  }\n\n  return jsonSchemas\n}\n"],"names":[],"mappings":";AAEA,MAAM,cAAc,CAAC,IAAY,OAA2B;AAC1D,SAAO,OAAO,UAAU,GAAG,EAAE,UAAU;AACzC;AAEA,MAAM,kBAAkB,CAAC,IAAY,OAA2B;AAC9D,SAAO,wBAAwB,YAAY,IAAI,EAAE,CAAC;AACpD;AAEA,SAAS,UAAU,QAAsC;AAEhD,SAAA,OAAO,YAAY,SAAS;AACrC;AAEA,MAAM,cAAc,CAClB,KAIA,OACG;AACH,MAAI,OAAO,UAAU;AAEf,QAAA,UAAU,IAAI,SAAS,GAAG;AAC5B,UAAI,WAAW,OAAO;AACtB,UAAI,WAAW,SAAS;AAAA,IAAA;AAAA,EAC1B;AAEJ;AAEA,MAAM,0BAEsD,CAAC,WAAW;AAChE,QAAA,SAAS,EAAE,GAAG,OAAO;AAE3B,SAAO,OAAO;AACd,SAAO,OAAO;AAEP,SAAA;AACT;AAEO,MAAM,kBAIqC,CAAC,WAAW,UAAU,OAAO;AACvE,QAAA,SAAS,EAAE,aAAa,WAAW;AAAA,IACvC;AAAA,IACA,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,UAAU;AAAA,MACR;AAAA,MACA,KAAK,CAAC,OAAO,gBAAgB,IAAI,EAAE;AAAA,MACnC,MAAM,CAAA;AAAA,IACR;AAAA,IACA,UAAU,CAAC,QAAQ,YAAY,KAAK,EAAE;AAAA,EAAA,CACvC;AAEK,QAAA,aAAa,wBAAwB,MAAM;AAE1C,SAAA;AACT;AAEa,MAAA,oBAGuC,CAAC,UAAU,OAAO;AAC9D,QAAA,SAAS,EAAE,aAAa,UAAU;AAAA,IACtC;AAAA,IACA,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,KAAK,CAAC,OAAO,gBAAgB,IAAI,EAAE;AAAA,IACnC,UAAU;AAAA,MACR;AAAA,MACA,KAAK,CAAC,OAAO,gBAAgB,IAAI,EAAE;AAAA,MACnC,MAAM,CAAA;AAAA,IACR;AAAA,IACA,UAAU,CAAC,QAAQ,YAAY,KAAK,EAAE;AAAA,EACvC,CAAA,EAAE;AAEH,QAAM,cAA4D,CAAC;AAEnE,aAAW,MAAM,QAAQ;AACX,gBAAA,YAAY,IAAI,EAAE,CAAC,IAAI,wBAAwB,OAAO,EAAE,CAAC;AAAA,EAAA;AAGhE,SAAA;AACT;"}